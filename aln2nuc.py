#! /usr/bin/env python

"""
Shipyard-style MiSeq pipeline, post-processing step
Takes CSV file generated by sam2aln.py (corresponding to a sample)
and clips out sequence regions corresponding to sub-regions as
indicated by a CSV file containing the respective nucleotide
reference sequences.

Dependencies:
    hyphyAlign.py
"""

import argparse
import HyPhy
import itertools
import os

import hyphyAlign
import project_config

parser = argparse.ArgumentParser(
    description='Clip out sub-regions from MiSeq read alignments.')

parser.add_argument('aligned_csv', help='<input> CSV containing aligned and merged reads.')
parser.add_argument('nuc_variants', help='<output> CSV containing clipped sequences')

args = parser.parse_args()


hyphy = HyPhy._THyPhy(os.getcwd(), 1)  # @UndefinedVariable
hyphyAlign.change_settings(hyphy, alphabet=hyphyAlign.nucAlphabet,
                           scoreMatrix=hyphyAlign.nucScoreMatrix,
                           gapOpen=20, gapOpen2=20,
                           gapExtend=10, gapExtend2=10,
                           noTerminalPenalty=1)

# distribution of mean alignment scores are very bimodal, easy to split
# note score is incremented by 5 for every matching bp
min_avg_score = 2.


def main():
    projects = project_config.ProjectConfig.loadDefault()

    handle = open(args.aligned_csv, 'rb')
    outfile = open(args.nuc_variants, 'w')
    
    handle.readline() # skip header
    outfile.write('sample,seed,qcut,region,index,count,seq\n')

    for key, group in itertools.groupby(handle, lambda x: x.split(',')[0:2]):
        sample_name, seed = key
        coord_refs = projects.getCoordinateReferences(seed)
        if not coord_refs:
            continue

        for qcut, group2 in itertools.groupby(group, lambda x: x.split(',')[2]):
            fasta = dict([(subregion, {}) for subregion in coord_refs.iterkeys()])
            for line in group2:
                (_sample_name,
                 _seedname,
                 _qcut,
                 index,
                 count,
                 _offset,
                 seq) = line.strip('\n').split(',')
                for subregion, refseq in coord_refs.iteritems():
                    aquery, aref, ascore = hyphyAlign.pair_align(hyphy, refseq, seq)
                    #TODO: Move this to aln2counts, because the subregion reference is now an amino acid sequence.
                    print subregion, refseq
                    print aquery
                    print aref
                    print float(ascore) / len(refseq)
                    if float(ascore) / len(refseq) < min_avg_score:
                        continue

                    left, right = hyphyAlign.get_boundaries(aref)
                    clipped_seq = aquery[left:right]
                    if clipped_seq not in fasta[subregion]:
                        fasta[subregion].update({clipped_seq: 0})
                    fasta[subregion][clipped_seq] += int(count)

            # re-compress sequence variants clipped to subregion
            for subregion in fasta.iterkeys():
                intermed = [(count, seq) for seq, count in fasta[subregion].iteritems()]
                intermed.sort(reverse=True)  # descending order
                for index, (count, seq) in enumerate(intermed):
                    outfile.write('%s,%s,%s,%s,%d,%d,%s\n' % (sample_name,
                                                              seed,
                                                              qcut,
                                                              subregion,
                                                              index,
                                                              count,
                                                              seq))

    handle.close()
    outfile.close()


if __name__ == '__main__':
    main()
